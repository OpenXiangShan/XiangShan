// Copyright (c) 2024-2025 Beijing Institute of Open Source Chip (BOSC)
// Copyright (c) 2020-2025 Institute of Computing Technology, Chinese Academy of Sciences
// Copyright (c) 2020-2021 Peng Cheng Laboratory
//
// XiangShan is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//          https://license.coscl.org.cn/MulanPSL2
//
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
// EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
// MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
//
// See the Mulan PSL v2 for more details.

package xiangshan.frontend.bpu.ras

import chisel3._
import chisel3.util._
import org.chipsalliance.cde.config.Parameters
import utility.HasCircularQueuePtrHelper
import utility.XSError
import utility.XSPerfAccumulate
import xiangshan.frontend.PrunedAddr
import xiangshan.frontend.PrunedAddrInit
import xiangshan.frontend.bpu.BasePredictor
import xiangshan.frontend.bpu.BasePredictorIO
import xiangshan.frontend.bpu.BranchAttribute
import xiangshan.frontend.bpu.HalfAlignHelper
import xiangshan.frontend.bpu.StageCtrl

/**
 * A speculative micro Return Address Stack (micro-RAS) used in the branch predictor.
 *
 * This module tracks pending call/return operations in the S1–S3 pipeline stages
 * and predicts the return target for upcoming RET instructions by modeling
 * the effect of in-flight push/pop operations on the main RAS.
 *
 * It outputs a predicted return address and a validity flag indicating whether
 * the prediction can be trusted in the current cycle.
 */
class MicroRas(implicit p: Parameters) extends BasePredictor with HasRasParameters with HalfAlignHelper {
  class MicroRasIO(implicit p: Parameters) extends BasePredictorIO {

    /** Input bundle containing speculative CFI (Control Flow Instruction) info from S1 */
    class MicroRasSpecIn extends Bundle {
      val startPc:     PrunedAddr      = PrunedAddr(VAddrBits)
      val cfiPosition: UInt            = UInt(CfiPositionWidth.W)
      val attribute:   BranchAttribute = new BranchAttribute
    }

    /** Output bundle providing predicted return target and validity */
    class MicroRasSpecOut extends Bundle {
      val retTarget: PrunedAddr = PrunedAddr(VAddrBits) // Predicted return address
      val isCanUse:  Bool       = Bool()                // Whether the prediction is valid
    }
    val specIn:      MicroRasSpecIn  = Input(new MicroRasSpecIn)
    val specOut:     MicroRasSpecOut = Output(new MicroRasSpecOut)
    val hasRedirect: Bool            = Input(Bool())                // Global redirect signal (e.g., misprediction)
    val hasOverride: Bool            = Input(Bool())                // S3-level override (flushes S1–S2)
    val fullRetAddr: PrunedAddr      = Input(PrunedAddr(VAddrBits)) // Current top of the main RAS
  }
  val io = IO(new MicroRasIO)
  io.resetDone  := true.B
  io.trainReady := true.B

  // Track whether S2/S3 stages contain pending push/pop operations
  private val s2_hasPush = RegInit(false.B)
  private val s2_hasPop  = RegInit(false.B)
  private val s3_hasPush = RegInit(false.B)
  private val s3_hasPop  = RegInit(false.B)

  // Store return addresses generated by speculative pushes in S2 and S3
  private val s2_retAddr = RegInit(0.U.asTypeOf(PrunedAddr(VAddrBits)))
  private val s3_retAddr = RegInit(0.U.asTypeOf(PrunedAddr(VAddrBits)))

  // Final output: whether a valid return target is available, and what its target is.
  private val isCanUse   = RegInit(false.B)
  private val topRetAddr = RegInit(0.U.asTypeOf(PrunedAddr(VAddrBits)))

  // Decode speculative operation from S1 input
  private val specPush = io.specIn.attribute.isCall
  private val specPop  = io.specIn.attribute.isReturn
  // Compute return address for a CALL
  private val specPushAddr = getCfiPcFromPosition(io.specIn.startPc, io.specIn.cfiPosition) + 2.U

  // One-cycle delayed version of redirect; used to detect RAS recovery state
  private val redirectDelay1 = RegNext(io.hasRedirect, init = false.B)

  // -------------------------------
  // Pipeline control for S2 stage
  // -------------------------------
  when(io.hasOverride || io.hasRedirect) {
    s2_hasPush := false.B
    s2_hasPop  := false.B
  }.elsewhen(io.stageCtrl.s1_fire) {
    s2_hasPush := specPush
    s2_hasPop  := specPop
  }.elsewhen(io.stageCtrl.s2_fire) {
    s2_hasPush := false.B
    s2_hasPop  := false.B
  }

  // -------------------------------
  // Pipeline control for S3 stage
  // -------------------------------
  when(io.hasRedirect) {
    // Redirect flushes entire pipeline, including S3
    s3_hasPush := false.B
    s3_hasPop  := false.B
  }.elsewhen(io.stageCtrl.s2_fire) {
    // Move S2 ops into S3
    s3_hasPush := s2_hasPush
    s3_hasPop  := s2_hasPop
  }.elsewhen(io.stageCtrl.s3_fire) {
    // Clear S3 after it completes
    s3_hasPush := false.B
    s3_hasPop  := false.B
  }

  // Capture return address for speculative CALL in S1 → store in S2
  when(io.stageCtrl.s1_fire && specPush) {
    s2_retAddr := specPushAddr
  }

  // Pass return address from S2 to S3
  when(io.stageCtrl.s2_fire) {
    s3_retAddr := s2_retAddr
  }

  // ------------------------------------------------------------
  // Main logic: compute the effective top-of-stack return address
  // that should be used by S1 in the next cycle.
  // ------------------------------------------------------------
  when(io.hasRedirect) {
    // On redirect, the main RAS state is being restored,
    // and the S1–S3 pipeline is flushed → no valid prediction.
    isCanUse := false.B
  }.elsewhen(io.hasOverride) {
    // On S3 override (e.g., late redirect), S1–S2 are flushed.
    // Only S3’s operation affects the RAS state seen by the next S1:
    // - If S3 pops, the main RAS top changes → prediction invalid.
    // - If S3 pushes, the new top is s3_retAddr.
    // - If S3 does nothing, the top remains io.fullRetAddr (main RAS).
    isCanUse   := Mux(s3_hasPop, false.B, Mux(s3_hasPush, true.B, true.B))
    topRetAddr := Mux(s3_hasPop, 0.U.asTypeOf(PrunedAddr(VAddrBits)), Mux(s3_hasPush, s3_retAddr, io.fullRetAddr))
  }.elsewhen(io.stageCtrl.s1_fire && specPush) {
    // S1 sees a CALL → next cycle’s RAS top will be the return address of this CALL.
    isCanUse   := true.B
    topRetAddr := specPushAddr
  }.elsewhen(io.stageCtrl.s1_fire && specPop) {
    // S1 sees a RET → we must predict what the RAS top will be after resolving
    // in-flight pushes/pops in S2 and S3.
    when(s2_hasPush) {
      // S2 push pairs with this S1 pop → net effect: cancel out.
      // But S3 may still modify the stack:
      // - If S3 pushes → new top is s3_retAddr.
      // - If S3 pops → stack depth decreases unpredictably → invalid.
      // - Otherwise → top reverts to main RAS (io.fullRetAddr).
      isCanUse   := Mux(s3_hasPush, true.B, Mux(s3_hasPop, false.B, true.B))
      topRetAddr := Mux(s3_hasPush, s3_retAddr, Mux(s3_hasPop, 0.U.asTypeOf(PrunedAddr(VAddrBits)), io.fullRetAddr))
    }.elsewhen(s2_hasPop) {
      // S2 also pops → stack underflow or unknown state → prediction invalid.
      isCanUse := false.B
    }.elsewhen(s3_hasPush) {
      // S2 neutral, but S3 pushes → S1 pop pairs with S3 push.
      // Thus, the effective top remains the current main RAS top.
      isCanUse   := true.B
      topRetAddr := io.fullRetAddr
    }.otherwise {
      // No pairing possible; main RAS will be popped → unknown new top.
      isCanUse := false.B
    }
  }.elsewhen(io.stageCtrl.s1_fire) {
    // S1 processes a non-CFI (or non-call/ret) instruction.
    // We still need to predict the RAS top for potential future RETs.
    when(s2_hasPush) {
      // S2 push → new top is s2_retAddr.
      isCanUse   := true.B
      topRetAddr := s2_retAddr
    }.elsewhen(s2_hasPop) {
      // S2 pop → main RAS will be popped.
      // Only safe if S3 pushes (which cancels the pop effect).
      isCanUse   := Mux(s3_hasPush, true.B, false.B)
      topRetAddr := Mux(s3_hasPush, io.fullRetAddr, 0.U.asTypeOf(PrunedAddr(VAddrBits)))
    }.elsewhen(s3_hasPop) {
      // S2 neutral, but S3 pops → main RAS changes unpredictably.
      isCanUse := false.B
    }.elsewhen(s3_hasPush) {
      // S3 push → new top is s3_retAddr.
      isCanUse   := true.B
      topRetAddr := s3_retAddr
    }.otherwise {
      // No pending ops → top is main RAS, unless RAS is recovering from redirect.
      isCanUse   := Mux(redirectDelay1, false.B, true.B)
      topRetAddr := Mux(redirectDelay1, 0.U.asTypeOf(PrunedAddr(VAddrBits)), io.fullRetAddr)
    }
  }

  io.specOut.isCanUse  := isCanUse
  io.specOut.retTarget := topRetAddr
}

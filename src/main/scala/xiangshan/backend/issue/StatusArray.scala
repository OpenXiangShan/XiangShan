package xiangshan.backend.issue

import chipsalliance.rocketchip.config.Parameters
import chisel3._
import chisel3.util._
import utility.HasCircularQueuePtrHelper
import utils.{MathUtils, OptionWrapper, XSError}
import xiangshan._
import xiangshan.backend.Bundles._
import xiangshan.backend.datapath.DataSource
import xiangshan.backend.fu.FuType
import xiangshan.backend.fu.vector.Utils.NOnes
import xiangshan.backend.rob.RobPtr
import xiangshan.mem.{MemWaitUpdateReq, SqPtr}

class StatusEntryMemPart(implicit p:Parameters, params: IssueBlockParams) extends Bundle {
  val waitForSqIdx = new SqPtr   // generated by store data valid check
  val waitForRobIdx = new RobPtr // generated by store set
  val waitForStd = Bool()
  val strictWait = Bool()
  val sqIdx = new SqPtr
}

class StatusEntry(implicit p:Parameters, params: IssueBlockParams) extends Bundle {
  val srcState = Vec(params.numRegSrc, SrcState())

  val psrc = Vec(params.numRegSrc, UInt(params.rdPregIdxWidth.W))
  val srcType = Vec(params.numRegSrc, SrcType())
  val robIdx = new RobPtr
  val issued = Bool()           // for predict issue
  val firstIssue = Bool()
  val blocked = Bool()          // for some block reason
  // read reg or get data from bypass network
  val dataSources = Vec(params.numRegSrc, DataSource())
  // if waked up by iq, set when waked up by iq
  val srcWakeUpL1ExuOH = OptionWrapper(params.hasIQWakeUp, Vec(params.numRegSrc, ExuVec()))
  // src timer, used by cancel signal. It increases every cycle after wakeup src inst issued.
  val srcTimer = OptionWrapper(params.hasIQWakeUp, Vec(params.numRegSrc, UInt(3.W)))

  // mem only
  val mem = if (params.isMemAddrIQ) Some(new StatusEntryMemPart) else None

  def srcReady: Bool = {
    VecInit(srcState.map(SrcState.isReady)).asUInt.andR
  }

  def canIssue: Bool = {
    srcReady && !issued && !blocked
  }
}

class StatusArrayEnqBundle(implicit p:Parameters, params: IssueBlockParams) extends Bundle {
  val addrOH = UInt(params.numEntries.W)
  val data = new StatusEntry()
}

class StatusArrayDeqRespBundle(implicit p:Parameters, params: IssueBlockParams) extends Bundle {
  val addrOH = UInt(params.numEntries.W)
  val respType = RSFeedbackType()   // update credit if needs replay
  val dataInvalidSqIdx = new SqPtr
  val rfWen = Bool()
  val fuType = FuType()
}

class StatusArrayDeqBundle(implicit p:Parameters, params: IssueBlockParams) extends Bundle {
  val isFirstIssue = Output(Bool())
  val deqSelOH = Flipped(ValidIO(UInt(params.numEntries.W)))
}

class StatusArrayIO(implicit p: Parameters, params: IssueBlockParams) extends XSBundle {
  val flush = Flipped(ValidIO(new Redirect))
  // status
  val valid = Output(UInt(params.numEntries.W))
  val canIssue = Output(UInt(params.numEntries.W))
  val clear = Output(UInt(params.numEntries.W))
  val dataSources = Output(Vec(params.numEntries, Vec(params.numRegSrc, DataSource())))
  val srcWakeUpL1ExuOH = OptionWrapper(params.hasIQWakeUp, Output(Vec(params.numEntries, Vec(params.numRegSrc, ExuVec()))))
  val srcTimer = OptionWrapper(params.hasIQWakeUp, Output(Vec(params.numEntries, Vec(params.numRegSrc, UInt(3.W)))))
  // enq
  val enq = Vec(params.numEnq, Flipped(ValidIO(new StatusArrayEnqBundle)))
  // wakeup
  val wakeUpFromWB: MixedVec[ValidIO[IssueQueueWBWakeUpBundle]] = Flipped(params.genWBWakeUpSinkValidBundle)
  val wakeUpFromIQ: MixedVec[ValidIO[IssueQueueIQWakeUpBundle]] = Flipped(params.genIQWakeUpSinkValidBundle)
  val og0Cancel = Input(ExuVec(backendParams.numExu))
  val og1Cancel = Input(ExuVec(backendParams.numExu))
  // deq
  val deq = Vec(params.numDeq, new StatusArrayDeqBundle)
  val deqResp = Vec(params.numDeq, Flipped(ValidIO(new StatusArrayDeqRespBundle)))
  val og0Resp = Vec(params.numDeq, Flipped(ValidIO(new StatusArrayDeqRespBundle)))
  val og1Resp = Vec(params.numDeq, Flipped(ValidIO(new StatusArrayDeqRespBundle)))

  val rsFeedback = Output(Vec(5, Bool()))
  // mem only
  val fromMem = if (params.isMemAddrIQ) Some(new Bundle {
    val stIssuePtr = Input(new SqPtr)
    val memWaitUpdateReq = Flipped(new MemWaitUpdateReq)
    val slowResp = Vec(params.numDeq, Flipped(ValidIO(new StatusArrayDeqRespBundle)))
    val fastResp = Vec(params.numDeq, Flipped(ValidIO(new StatusArrayDeqRespBundle)))
  }) else None

  def wakeup = wakeUpFromWB ++ wakeUpFromIQ
}

class StatusArray()(implicit p: Parameters, params: IssueBlockParams) extends XSModule {
  val io = IO(new StatusArrayIO)

  val publicResps = io.deqResp ++ io.og0Resp ++ io.og1Resp

  def resps: IndexedSeq[ValidIO[StatusArrayDeqRespBundle]] = publicResps

  val validVec = RegInit(VecInit(Seq.fill(params.numEntries)(false.B)))
  val statusVec = Reg(Vec(params.numEntries, new StatusEntry()))

  val validNextVec = Wire(Vec(params.numEntries, Bool()))
  val statusNextVec = Wire(Vec(params.numEntries, new StatusEntry()))

  val enqStatusVec = Wire(Vec(params.numEntries, ValidIO(new StatusEntry)))
  val srcWakeUpVec = Wire(Vec(params.numEntries, Vec(params.numRegSrc, Bool())))

  // just for better verilog
  dontTouch(validNextVec)
  dontTouch(statusNextVec)
  dontTouch(enqStatusVec)
  dontTouch(srcWakeUpVec)

  /**
    * srcWakeUpByIQMatrix(entryIdx)(srcIdx)(wakeUpIQIdx)
    */
  val srcWakeUpByIQMatrix = Wire(Vec(params.numEntries, Vec(params.numRegSrc, Vec(params.numWakeupFromIQ, Bool()))))
  val deqRespVec = Wire(Vec(params.numEntries, ValidIO(new StatusArrayDeqRespBundle)))
  val flushedVec = Wire(Vec(params.numEntries, Bool()))
  val clearVec = Wire(Vec(params.numEntries, Bool()))
  val deqSelVec = Wire(Vec(params.numEntries, Bool()))
  val deqSelVec2 = Wire(Vec(params.numDeq, Vec(params.numEntries, Bool())))            // per deq's deqSelVec

  // srcCancelVec2(entryIdx)(srcIdx): if this srcState will be set as NotReady
  val srcCancelVec2 = OptionWrapper(params.hasIQWakeUp, Wire(Vec(params.numEntries, Vec(params.numRegSrc, Bool()))))

  if (params.hasIQWakeUp) {
    srcCancelVec2.get.zipWithIndex.foreach { case (srcCancelVec, entryIdx) =>
      srcCancelVec.zipWithIndex.foreach { case (srcCancel, srcIdx) =>
        // level1 cancel: A(s)->C, A(s) are the level1 cancel
        val l1Cancel = (io.og0Cancel.asUInt & statusVec(entryIdx).srcWakeUpL1ExuOH.get(srcIdx).asUInt).orR &&
          statusVec(entryIdx).srcTimer.get(srcIdx) === 1.U
        srcCancel := l1Cancel
      }
    }
  }

  dontTouch(deqRespVec)
  // Reg
  validVec := validNextVec
  statusVec := statusNextVec

  // Wire
  enqStatusVec.zipWithIndex.foreach { case (enqStatus, i) =>
    val enqValidVec = io.enq.map(x => x.valid && x.bits.addrOH(i))
    XSError(PopCount(enqValidVec) > 1.U, "should not update the same entry\n")
    enqStatus.valid := VecInit(enqValidVec).asUInt.orR
    enqStatus.bits := Mux1H(enqValidVec, io.enq.map(_.bits.data))
  }

  validNextVec.zipWithIndex.foreach { case (validNext, i) =>
    when (enqStatusVec(i).valid) {
      validNext := true.B
    }.elsewhen(clearVec(i)) { // include rob flush
      validNext := false.B
    }.otherwise {
      validNext := validVec(i)
    }
  }

  statusNextVec.zip(statusVec).zipWithIndex.foreach { case ((statusNext, status), entryIdx) =>
    // alway update status when enq valid
    when (enqStatusVec(entryIdx).valid) {
      statusNext := enqStatusVec(entryIdx).bits
    }.otherwise {
      statusNext.psrc := status.psrc
      statusNext.srcState.zip(status.srcState).zip(srcWakeUpVec(entryIdx)).zipWithIndex.foreach { case (((stateNext, state), wakeup), srcIdx) =>
        val cancel = srcCancelVec2.map(_(entryIdx)(srcIdx)).getOrElse(false.B)
        stateNext := Mux(cancel, false.B, wakeup | state)
      }
      statusNext.dataSources.zip(status.dataSources).zip(srcWakeUpByIQMatrix(entryIdx)).foreach {
        case ((dataSourceNext: DataSource, dataSource: DataSource), wakeUpByIQOH: Vec[Bool]) =>
          when (wakeUpByIQOH.asUInt.orR) {
            dataSourceNext.value := DataSource.forward
          }.elsewhen(dataSource.value === DataSource.forward) {
            dataSourceNext.value := DataSource.bypass
          }.otherwise {
            dataSourceNext.value := DataSource.reg
          }
      }
      if (params.hasIQWakeUp) {
        statusNext.srcWakeUpL1ExuOH.get.zip(srcWakeUpByIQMatrix(entryIdx)).zipWithIndex.foreach {
          case ((exuOH: Vec[Bool], wakeUpByIQOH: Vec[Bool]), srcIdx) =>
            when(wakeUpByIQOH.asUInt.orR) {
              exuOH := Mux1H(wakeUpByIQOH, io.wakeUpFromIQ.map(x => MathUtils.IntToOH(x.bits.exuIdx).U(backendParams.numExu.W))).asBools
            }.otherwise {
              exuOH := status.srcWakeUpL1ExuOH.get(srcIdx)
            }
        }
        statusNext.srcTimer.get.zip(status.srcTimer.get).zip(srcWakeUpByIQMatrix(entryIdx)).zipWithIndex.foreach {
          case (((srcIssuedTimerNext, srcIssuedTimer), wakeUpByIQOH: Vec[Bool]), srcIdx) =>
            srcIssuedTimerNext := MuxCase(0.U, Seq(
              // T0: waked up by IQ, T1: reset timer as 1
              wakeUpByIQOH.asUInt.orR -> 1.U,
              // do not overflow
              srcIssuedTimer.andR -> srcIssuedTimer,
              // T2+: increase if this entry has still been valid, and this src has still been ready
              (validVec(entryIdx) && SrcState.isReady(status.srcState(srcIdx)) && status.srcWakeUpL1ExuOH.get.asUInt.orR) -> (srcIssuedTimer + 1.U)
            ))
        }
      }
      statusNext.blocked := false.B // Todo
      statusNext.robIdx := status.robIdx
      statusNext.srcType := status.srcType
      statusNext.firstIssue := status.firstIssue || deqSelVec(entryIdx)

      statusNext.issued := status.issued // otherwise
      when (!status.srcReady) {
        statusNext.issued := false.B
      }.elsewhen (deqRespVec(entryIdx).valid) {
        when (RSFeedbackType.isStageSuccess(deqRespVec(entryIdx).bits.respType)) {
          statusNext.issued := true.B
        }.elsewhen (RSFeedbackType.isBlocked(deqRespVec(entryIdx).bits.respType)) {
          statusNext.issued := false.B
        }
      }
    }
  }

  srcWakeUpVec.zipWithIndex.foreach { case (wakeups: Vec[Bool], i) =>
    // wakeupVec(i)(j): the ith psrc woken up by the jth bundle
    val wakeupVec: IndexedSeq[IndexedSeq[Bool]] = io.wakeup.map(bundle =>
      bundle.bits.wakeUp(statusVec(i).psrc zip statusVec(i).srcType, bundle.valid)).transpose
    wakeups := wakeupVec.map(VecInit(_).asUInt.orR)
  }

  srcWakeUpByIQMatrix.zipWithIndex.foreach { case (wakeups: Vec[Vec[Bool]], i) =>
    if (io.wakeUpFromIQ.isEmpty) {
      wakeups := 0.U.asTypeOf(wakeups)
    } else {
      val wakeupVec: IndexedSeq[IndexedSeq[Bool]] = io.wakeUpFromIQ.map((bundle: ValidIO[IssueQueueIQWakeUpBundle]) =>
        bundle.bits.wakeUp(statusVec(i).psrc zip statusVec(i).srcType, bundle.valid)
      ).transpose
      wakeups := wakeupVec.map(x => VecInit(x))
    }
  }

  deqSelVec.zipWithIndex.foreach { case (deqSel: Bool, i) =>
    deqSel := VecInit(io.deq.map(x => x.deqSelOH.valid && x.deqSelOH.bits(i))).asUInt.orR
  }

  deqSelVec2.zip(io.deq).foreach { case (deqSelVecSingle, deqSingle) =>
    deqSelVecSingle.zipWithIndex.foreach { case (deqSelBool, i) =>
      deqSelBool := deqSingle.deqSelOH.valid && deqSingle.deqSelOH.bits(i)
    }
  }

  deqRespVec.zipWithIndex.foreach { case (deqResp, i) =>
    val deqRespValidVec = VecInit(resps.map(x => x.valid && x.bits.addrOH(i)))
    XSError(PopCount(deqRespValidVec) > 1.U, p"status deq resp ${Binary(deqRespValidVec.asUInt)} should be one-hot)\n")
    deqResp.valid := deqRespValidVec.asUInt.orR
    deqResp.bits := Mux1H(deqRespValidVec, resps.map(_.bits))
  }

  flushedVec.zipWithIndex.foreach { case (flushed, i) =>
    flushed := statusNextVec(i).robIdx.needFlush(io.flush)
  }

  // (1) flushed by rob
  // (2) deq success
  clearVec.zipWithIndex.foreach { case (clear, i) =>
    val clearByFlush = (enqStatusVec(i).valid || validVec(i)) && flushedVec(i)
    val clearByResp = deqRespVec(i).valid && deqRespVec(i).bits.respType === RSFeedbackType.fuIdle

    clear := clearByFlush || clearByResp
  }

  val canIssueVec = Wire(Vec(params.numEntries, Bool()))
  canIssueVec.zipWithIndex.foreach { case (canIssue, i) =>
    canIssue := validVec(i) && statusVec(i).canIssue
  }

  io.valid := validVec.asUInt
  io.canIssue := canIssueVec.asUInt
  io.clear := clearVec.asUInt
  io.dataSources := statusVec.map(_.dataSources)
  io.srcWakeUpL1ExuOH.foreach(_ := statusVec.map(_.srcWakeUpL1ExuOH.get))
  io.srcTimer.foreach(_ := statusVec.map(_.srcTimer.get))
  io.rsFeedback := 0.U.asTypeOf(io.rsFeedback)
  io.deq.zip(deqSelVec2).foreach { case (deqSingle, deqSelVecSingle) =>
    deqSingle.isFirstIssue := Mux1H(deqSelVecSingle, statusVec.map(!_.firstIssue))
  }
  dontTouch(io.deq)
}

class StatusArrayMem()(implicit p: Parameters, params: IssueBlockParams) extends StatusArray
  with HasCircularQueuePtrHelper {

  val fromMem = io.fromMem.get

  override def resps: IndexedSeq[ValidIO[StatusArrayDeqRespBundle]] = super.resps ++ io.fromMem.get.slowResp ++ io.fromMem.get.fastResp

  statusNextVec.zip(statusVec).zipWithIndex.foreach { case ((statusNext, status), i) =>
    val memStatus = status.mem.get
    val memStatusNext = statusNext.mem.get
    // load cannot be issued before older store, unless meet some condition
    val blockedByOlderStore = isAfter(memStatusNext.sqIdx, fromMem.stIssuePtr)

    val deqFailedForStdInvalid = deqRespVec(i).valid && deqRespVec(i).bits.respType === RSFeedbackType.dataInvalid

    val staWaitedReleased = Cat(
      fromMem.memWaitUpdateReq.staIssue.map(x => x.valid && x.bits.uop.robIdx.value === memStatusNext.waitForRobIdx.value)
    ).orR
    val stdWaitedReleased = Cat(
      fromMem.memWaitUpdateReq.stdIssue.map(x => x.valid && x.bits.uop.sqIdx.value === memStatusNext.waitForSqIdx.value)
    ).orR
    val olderStaNotViolate = staWaitedReleased && !memStatusNext.strictWait
    val olderStdReady = stdWaitedReleased && memStatusNext.waitForStd
    val waitStd = !olderStdReady
    val waitSta = !olderStaNotViolate

    memStatusNext := memStatus
    when (enqStatusVec(i).valid) {
      // update by ssit at rename stage
      memStatusNext.strictWait    := enqStatusVec(i).bits.mem.get.strictWait
      // new load inst don't known if it is blocked by store data ahead of it
      memStatusNext.waitForStd    := false.B
      // update by lfst at dispatch stage
      memStatusNext.waitForRobIdx := enqStatusVec(i).bits.mem.get.waitForRobIdx
    }.elsewhen(deqFailedForStdInvalid) {
      // Todo: check if need assign statusNext.block
      memStatusNext.waitForStd    := true.B
      memStatusNext.waitForSqIdx  := deqRespVec(i).bits.dataInvalidSqIdx
    }.otherwise {
      // keep old value
    }

    val shouldBlock = Mux(enqStatusVec(i).valid, enqStatusVec(i).bits.blocked, status.blocked)
    val blockNotReleased = waitStd || waitSta
    val respBlock = deqFailedForStdInvalid
    statusNext.blocked := shouldBlock && blockNotReleased && blockedByOlderStore || respBlock
  }
}

object StatusArray {
  def apply(implicit p: Parameters, iqParams: IssueBlockParams): StatusArray = {
    iqParams.schdType match {
      case IntScheduler() => new StatusArray()
      case MemScheduler() =>
        if (iqParams.StdCnt == 0) new StatusArrayMem()
        else new StatusArray()
      case VfScheduler() => new StatusArray()
      case _ => null
    }
  }
}
